r"""
Linear family of coordinates on a veering triangulation
"""
# ****************************************************************************
#  This file is part of veerer
#
#       Copyright (C) 2023 Vincent Delecroix
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
# ****************************************************************************

from array import array
from copy import copy
import collections
import itertools
import numbers
from random import choice, shuffle

from sage.structure.element import get_coercion_model, Matrix
from sage.rings.integer_ring import ZZ
from sage.rings.rational_field import QQ
from sage.matrix.constructor import matrix
from sage.modules.free_module import FreeModule
from sage.geometry.polyhedron.constructor import Polyhedron
from sage.arith.misc import gcd
from sage.categories.number_fields import NumberFields

from .constants import VERTICAL, HORIZONTAL, BLUE, RED
from .permutation import perm_cycle_string, perm_cycles, perm_check, perm_conjugate, perm_on_list
from .polyhedron import LinearExpressions, ConstraintSystem
from .strebel_graph import StrebelGraph
from .veering_triangulation import VeeringTriangulation

cm = get_coercion_model()
_NumberFields = NumberFields()


def subspace_are_equal(subspace1, subspace2, check=True):
    r"""
    Test whether the subspaces generated by the rows of ``subspace1`` and
    ``subspace2`` are equal.

    INPUT:

    - ``subspace1``, ``subspace2`` -- full rank matrices with the same number
      of columns

    - ``check`` -- boolean (default ``True``)

    EXAMPLES::

        sage: from veerer.linear_family import subspace_are_equal  # random output due to deprecation warnings from realalg

        sage: m1 = random_matrix(ZZ, 3, 5)
        sage: m2 = copy(m1)
        sage: m2.add_multiple_of_row(0, 1, -2)
        sage: m2.add_multiple_of_row(0, 2, 1)
        sage: m2.add_multiple_of_row(1, 2, 1)
        sage: subspace_are_equal(m1, m2)
        True

        sage: m1 = matrix(ZZ, [[1, 1, 0]])
        sage: m2 = matrix(ZZ, [[1, 1, -1]])
        sage: subspace_are_equal(m1, m2)
        False
    """
    if check:
        if subspace1.ncols() != subspace2.ncols():
            raise ValueError('subspace1 and subspace2 of different ambient dimensions')
        if subspace1.rank() != subspace1.nrows():
            raise ValueError('subspace1 not full rank')
        if subspace2.rank() != subspace2.nrows():
            raise ValueErrror('subspace2 not full rank')

    n = subspace1.nrows()
    if n != subspace2.nrows():
        return False

    base_ring = cm.common_parent(subspace1.base_ring(), subspace2.base_ring())
    mat = matrix(base_ring, n + 1, subspace1.ncols())
    mat[:n] = subspace1
    for v in subspace2.rows():
        mat[n] = v
        r = mat.rank()
        if r < n:
            raise RuntimeError('matrices where expected to be full rank')
        if r > n:
            return False
    return True


def subspace_cmp(subspace1, subspace2, check=True):
    if check:
        if subspace1.ncols() != subspace2.ncols():
            raise ValueError('subspace1 and subspace2 of different ambient dimensions')
        if subspace1.rank() != subspace1.nrows():
            raise ValueError('subspace1 not full rank')
        if subspace2.rank() != subspace2.nrows():
            raise ValueErrror('subspace2 not full rank')

    n = subspace1.nrows()
    if n != subspace2.nrows():
        return False

    base_ring = cm.common_parent(subspace1.base_ring(), subspace2.base_ring())
    subspace1 = subspace1.echelon_form()
    subspace2 = subspace2.echelon_form()
    for r1, r2 in zip(subspace1, subspace2):
        c = (r1 > r2) - (r1 < r2)
        if c:
            return c
    return 0


def relabel_on_edges(ep, r, n, m):
    r"""
    INPUT:

    - ep - edge permutation

    - r - relabelling permutation on half edges (list of length n)

    - n - num half edges

    - m - num edges

    OUTPUT: list of length m

    EXAMPLES::

        sage: from array import array
        sage: from veerer.linear_family import relabel_on_edges

        sage: ep = array('i', [8, 1, 2, 7, 4, 5, 6, 3, 0])
        sage: r = array('i', [3, 0, 5, 4, 6, 2, 1, 8, 7])
        sage: relabel_on_edges(ep, r, 9, 7)
        array('i', [3, 0, 5, 4, 6, 2, 1])
    """
    rr = array('i', [-1] * m)
    for i in range(m):
        if ep[i] < i:
            raise ValueError("not in canonical form")
        j = r[i]
        k = r[ep[i]]
        if (j >= m and k >= m):
            raise ValueError("relabelling not preserving canonical form")
        if j < k:
            rr[i] = j
        else:
            rr[i] = k
    return rr


def matrix_permutation(mat, perm):
    r"""
    Permute in place the columns of ``mat`` according to the permutation ``perm``

    EXAMPLES::

        sage: from array import array
        sage: from veerer.linear_family import matrix_permutation

        sage: p = array('i', [2, 0, 1])
        sage: m = matrix([[0, 1, 2]])
        sage: matrix_permutation(m, p)
        sage: print(m)
        [1 2 0]
    """
    m = mat.ncols()
    for c in perm_cycles(perm, False, m):
        for i in range(1, len(c)):
            mat.swap_columns(c[0], c[i])


class LinearFamily:
    r"""
    Abstract class to handle linear coordinates on either veering triangulation
    or Strebel graph.

    The subspace is given by generators.
    """
    def __init__(self, *args, mutable=False, check=True):
        self._constellation_class_init()

        if len(args) < 2:
            raise ValueError('require at least two arguments')
        constellation_args = args[:-1]
        subspace = args[-1]
        self._constellation_class.__init__(self, *constellation_args, mutable=mutable, check=False)

        if not isinstance(subspace, Matrix):
            subspace = matrix(subspace)

        self._subspace = subspace
        self._subspace.echelonize()
        if not mutable:
            self._subspace.set_immutable()

        if check:
            self._check(ValueError)

    def _constellation_class_init(self):
        bases = self.__class__.__bases__
        if len(bases) != 2 or bases[0] != LinearFamily:
            raise ValueError
        self._constellation_class = bases[1]

    def _check(self, error=ValueError):
        self._constellation_class._check(self, error)
        subspace = self._subspace
        if subspace.ncols() != self.num_edges():
            raise error('subspace matrix has wrong dimension')
        if subspace.rank() != subspace.nrows():
            raise error('subspace matrix is not of full rank')
        if subspace != subspace.echelon_form():
            raise error('subspace not in echelon form')
        if self._mutable != self._subspace.is_mutable():
            raise error('incoherent mutability states')

    def __str__(self):
        r"""
        Return a string representation.

        TESTS::

            sage: from veerer import *
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", [RED, RED, BLUE])
            sage: str(vt.as_linear_family())
            'VeeringTriangulationLinearFamily("(0,1,2)(~2,~0,~1)", "RRB", [(1, 0, -1), (0, 1, 1)])'
        """
        cls_name = self._constellation_class.__name__
        s = str(self._constellation_class.__str__(self))
        i = s.find('(')
        return s[:i] + 'LinearFamily' + s[i:-1] + ', ' + str(self._subspace.rows()) + ')'

    def __repr__(self):
        return str(self)

    def __getstate__(self):
        R = self.base_ring()
        # NOTE: here we know that all entries have the same parent
        if R is ZZ:
            entries = list(map(int, self._subspace.list()))
        elif R is QQ:
            entries = []
            for x in self._subspace.list():
                entries.append(int(x.numerator()))
                entries.append(int(x.denominator()))
        elif _NumberFields is not None and R in _NumberFields:
            entries = []
            for x in self._subspace.list():
                v = x.vector()
                d = v.denominator()
                entries.extend(int(x) for x in (v * d))
                entries.append(int(d))
        else:
            entries = self._subspace.list()
        return self._constellation_class.__getstate__(self), R, entries

    def __setstate__(self, arg):
        r"""
        TESTS:

        An example over ZZ::

            sage: from veerer import VeeringTriangulation
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", "RRB")
            sage: lf = vt.as_linear_family()
            sage: lf2 = loads(dumps(lf))  # indirect doctest
            sage: assert lf == lf2
            sage: lf2._check()

        An example over number fields::

            sage: from veerer.linear_family import VeeringTriangulationLinearFamilies
            sage: lf = VeeringTriangulationLinearFamilies.triangle_3_4_13_unfolding_orbit_closure()
            sage: lf2 = loads(dumps(lf))  # indirect doctest
            sage: assert lf == lf2
            sage: lf2._check()
        """
        self._constellation_class_init()
        a, R, raw_entries = arg
        self._constellation_class.__setstate__(self, a)
        n = self._n
        for i in range(n):
            self._vp[self._fp[self._ep[i]]] = i

        if R is ZZ:
            entries = [ZZ(x) for x in raw_entries]
        elif R is QQ:
            entries = []
            for i in range(0, len(raw_entries), 2):
                entries.append(QQ((raw_entries[i], raw_entries[i + 1])))
        elif _NumberFields is not None and R in _NumberFields:
            entries = []
            d = R.degree()
            for i in range(0, len(raw_entries), d + 1):
                v = tuple(x / raw_entries[i + d] for x in raw_entries[i:i + d])
                entries.append(R(v))
        else:
            entries = raw_entries
        self._subspace = matrix(R, len(entries) // self.num_edges(), self.num_edges(), entries)
        if not self._mutable:
            self._subspace.set_immutable()

    def copy(self, mutable=None, cls=None):
        r"""
        Return a copy of this linear family.

        EXAMPLES::

            sage: from veerer import *
            sage: fp = "(0,1,2)(~0,~4,~2)(3,4,5)(~3,~1,~5)"
            sage: cols = "BRRBRR"
            sage: f = VeeringTriangulation(fp, cols).as_linear_family(mutable=False)
            sage: f
            VeeringTriangulationLinearFamily("(0,1,2)(3,4,5)(~5,~3,~1)(~4,~2,~0)", "BRRBRR", [(1, 0, 1, 0, 0, 0), (0, 1, 1, 0, 1, 1), (0, 0, 0, 1, 0, 1)])
            sage: f2 = f.copy(mutable=True)
            sage: f2
            VeeringTriangulationLinearFamily("(0,1,2)(3,4,5)(~5,~3,~1)(~4,~2,~0)", "BRRBRR", [(1, 0, 1, 0, 0, 0), (0, 1, 1, 0, 1, 1), (0, 0, 0, 1, 0, 1)])
            sage: f2._check()
            sage: f2._mutable
            True
        """
        if mutable is None:
            mutable = self._mutable

        if cls is None:
            cls = self.__class__

        if cls is self.__class__ and (not self._mutable and not mutable):
            # avoid copies of immutable objects
            return self

        if cls is not self.__class__:
            return super().copy(mutable, cls)

        L = self._constellation_class.copy(self, mutable=True, cls=self.__class__)
        L._constellation_class = self._constellation_class
        L._subspace = copy(self._subspace)
        if not mutable:
            L._subspace.set_immutable()
        return L

    def base_ring(self):
        r"""
        Return the underlying base ring of the linear family.
        """
        return self._subspace.base_ring()

    def set_immutable(self):
        self._constellation_class.set_immutable(self)
        self._subspace.set_immutable()

    def __hash__(self):
        r"""
        TESTS::

            sage: from veerer import VeeringTriangulation
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", "RRB")
            sage: h = hash(vt.as_linear_family())
        """
        if self._mutable:
            raise ValueError('mutable veering triangulation linear family not hashable')

        x = self._constellation_class.__hash__(self)
        x = ((x ^ hash(self._subspace) * 2147483693)) + 82520 + self._n + self._n

        return x

    def __eq__(self, other):
        r"""
        TESTS::

            sage: from veerer import *
            sage: vt, s, t = VeeringTriangulations.L_shaped_surface(1,1,1,1)
            sage: s = vector(QQ, s)
            sage: t = vector(QQ, t)
            sage: f1 = VeeringTriangulationLinearFamily(vt, [s, t])
            sage: f2 = VeeringTriangulationLinearFamily(vt, [s + 2*t, -s - t])
            sage: f1 == f2
            True
            sage: from veerer import *
            sage: vt2, s2, t2 = VeeringTriangulations.L_shaped_surface(1,2,1,3)
            sage: f3 = VeeringTriangulationLinearFamily(vt2, [s2, t2])
            sage: f1 == f3
            False
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", [RED, RED, BLUE])
            sage: vt.as_linear_family() == f1
            False
        """
        if type(self) is not type(other):
            raise TypeError
        return self._constellation_class.__eq__(self, other) and self._subspace == other._subspace

    def __ne__(self, other):
        r"""
        TESTS::

            sage: from veerer import *
            sage: vt, s, t = VeeringTriangulations.L_shaped_surface(1,1,1,1)
            sage: s = vector(QQ, s)
            sage: t = vector(QQ, t)
            sage: f1 = VeeringTriangulationLinearFamily(vt, [s, t])
            sage: f2 = VeeringTriangulationLinearFamily(vt, [s + 2*t, -s - t])
            sage: f1 != f2
            False
            sage: from veerer import *
            sage: vt2, s2, t2 = VeeringTriangulations.L_shaped_surface(1,2,1,3)
            sage: f3 = VeeringTriangulationLinearFamily(vt2, [s2, t2])
            sage: f1 != f3
            True
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", [RED, RED, BLUE])
            sage: vt.as_linear_family() != f1
            True
        """
        if type(self) is not type(other):
            raise TypeError
        return self._constellation_class.__ne__(self, other) or self._subspace != other._subspace

    def _richcmp_(self, other, op):
        c = (self._n > other._n) - (self._n < other._n)
        if c:
            return rich_to_bool(op, c)

        c = (self._colouring > other._colouring) - (self._colouring < other._colouring)
        if c:
            return rich_to_bool(op, c)

        c = (self._fp > other._fp) - (self._fp < other._fp)
        if c:
            return rich_to_bool(op, c)

        c = (self._ep > other._ep) - (self._ep < other._ep)
        if c:
            return rich_to_bool(op, c)

        c = subspace_cmp(self._subspace, other._subspace)
        return rich_to_bool(op, c)

    def dimension(self):
        r"""
        Return the dimension of the linear family.

        EXAMPLES::

            sage: from veerer import StrebelGraphLinearFamily
            sage: G = StrebelGraphLinearFamily("(0,1,2)(~0,~1:1,~2:2)", [(1, 1, 0), (1, 0, 1)])
            sage: G.dimension()
            2
        """
        return self._subspace.nrows()

    def constraints_matrix(self, mutable=None):
        r"""
        Return a basis of constraints on x-coordinates as a matrix.

        EXAMPLES::

            sage: from veerer import VeeringTriangulation, StrebelGraph
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", "RRB")
            sage: vt.as_linear_family().constraints_matrix().echelon_form()
            [ 1 -1  1]

            sage: F = StrebelGraph("(0,2,~3,~1)(1)(3,~0)(~2)").add_residue_constraints([[1, 2, 0, 0]])
            sage: F.constraints_matrix().echelon_form()
            [ 1 -1  1  1]
        """
        return self._subspace.right_kernel_matrix()

    def generators_matrix(self, mutable=None):
        r"""
        Return a basis of generators of x-coordinates as a matrix.

        EXAMPLES::

            sage: from veerer import VeeringTriangulation, StrebelGraph
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", "RRB")
            sage: vt.as_linear_family().generators_matrix().echelon_form()
            [ 1  0 -1]
            [ 0  1  1]

            sage: F = StrebelGraph("(0,2,~3,~1)(1)(3,~0)(~2)").add_residue_constraints([[1, 2, 0, 0]])
            sage: F.generators_matrix().echelon_form()
            [ 1  0  0 -1]
            [ 0  1  0  1]
            [ 0  0  1 -1]
        """
        if not self._mutable and not mutable:
            return self._subspace
        else:
            subspace = self._subspace.__copy__()
            if not mutable:
                subspace.set_immutable()
            return subspace

    def residue_constraints(self):
        r"""
        Return a basis of residue constraints.

        If the family is not made of Abelian differentials, a ``ValueError`` is raised.

        For meromorphic differentials, the space of residue constraints is at
        least one-dimensional since the sum of residues is zero.

        EXAMPLES::

            sage: from veerer import StrebelGraph, VeeringTriangulation

            sage: G = StrebelGraph("(0,2,~3,~1)(1)(3,~0)(~2)")
            sage: G.as_linear_family().residue_constraints().echelon_form()
            [1 1 1 1]

            sage: F = G.add_residue_constraints([[1, 2, 0, 0]])
            sage: F.residue_constraints().echelon_form()
            [ 1  0  2  2]
            [ 0  1 -1 -1]

            sage: V = VeeringTriangulation("(0,5,~4)(2,6,~5)(3,~0,7)(4,~3,~1)", boundary="(1:1)(~7:1)(~6:1)(~2:1)", colouring="RRRBBBBR")

            sage: V.as_linear_family().residue_constraints().echelon_form()
            [1 1 1 1]

            sage: F = V.add_residue_constraints([[1, 2, 0, 0]])
            sage: F.residue_constraints().echelon_form()
            [ 1  0  2  2]
            [ 0  1 -1 -1]

        For holomorphic differentials, there is no residue constraint::

            sage: fp = "(0,1,2)(~0,~4,~2)(3,4,5)(~3,~1,~5)"
            sage: cols = "BRRBRR"
            sage: f = VeeringTriangulation(fp, cols).as_linear_family(mutable=True)
            sage: f.residue_constraints()
            []
        """
        # We want vectors that are linear combinations of self.residue_matrix()
        # and self.constraints_matrix().
        residue_matrix = self.residue_matrix()
        intersection = residue_matrix.row_module().intersection(self.constraints_matrix().row_module()).matrix()
        nr = intersection.nrows() + residue_matrix.nrows() - residue_matrix.rank()
        nc = self.num_boundary_faces()
        return matrix(self.base_ring(), nr,  nc, [residue_matrix.solve_left(v) for v in intersection.rows()] + residue_matrix.left_kernel_matrix().rows())

    def stratum(self):
        return self.copy(self, cls=self._constellation_class).stratum()

    def relabel(self, p, check=True):
        r"""
        Relabel inplace the veering triangulation linear family according to the permutation ``p``.

        EXAMPLES:

        Relabelling the subspace as well::

            sage: from veerer import VeeringTriangulations, VeeringTriangulationLinearFamily
            sage: from veerer.permutation import perm_random_centralizer

            sage: vt, s, t = VeeringTriangulations.L_shaped_surface(2, 3, 4, 5, 1, 2)
            sage: f = VeeringTriangulationLinearFamily(vt, [s, t], mutable=True)
            sage: for _ in range(10):
            ....:     p = f._relabelling_from(choice(range(9)))
            ....:     f.relabel(p)
            ....:     f._check()

            sage: for _ in range(10):
            ....:     p = perm_random_centralizer(f.edge_permutation(copy=False))
            ....:     f.relabel(p)
            ....:     f._check()
        """
        n = self.num_half_edges()
        m = self.num_edges()
        ep = self._ep
        if check and not perm_check(p, n):
            p = perm_init(p, n, ep)
            if not perm_check(p, n):
                raise ValueError('invalid relabelling permutation')

        rr = relabel_on_edges(self._ep, p, n, m)
        matrix_permutation(self._subspace, rr)
        self._subspace.echelonize()
        self._constellation_class.relabel(self, p, False)

        # TODO: remove check
        self._check()

    def best_relabelling(self, all=False):
        r"""
        Return the smallest relabelling of this linear family.
        """
        n = self.num_half_edges()
        m = self.num_edges()

        best = None
        if all:
            relabellings = []

        for start_edge in self._automorphism_good_starts():
            relabelling = self._relabelling_from(start_edge)
            rr = relabel_on_edges(self._ep, relabelling, n, m)

            fp_new = perm_conjugate(self._fp, relabelling)
            ep_new = perm_conjugate(self._ep, relabelling)
            data_new = [l[:] for l in self._data]
            for l in data_new:
                perm_on_list(relabelling, l, self._n)

            subspace_new = copy(self._subspace)
            matrix_permutation(subspace_new, rr)
            subspace_new.echelonize()
            subspace_new.set_immutable()

            T = (fp_new, ep_new, data_new, subspace_new)
            if best is None or T < best:
                best = T
                best_relabelling = relabelling
                if all:
                    del relabellings[:]
                    relabellings.append(relabelling)
            elif all and T == best:
                relabellings.append(relabelling)

        return (relabellings, best) if all else (best_relabelling, best)

    def _non_isom_easy(self, other):
        return (self._constellation_class._non_isom_easy(self, other) or
                self._subspace.nrows() != other._subspace.nrows())

    def as_linear_family(self, mutable=False):
        if not mutable and not self._mutable:
            return self
        return self.copy(mutable)

    def abelian_cover(self, mutable=False):
        r"""
        Return the Abelian double cover.

        EXAMPLES::

            sage: from veerer.linear_family import VeeringTriangulationLinearFamilies, StrebelGraphLinearFamily

            sage: X9 = VeeringTriangulationLinearFamilies.prototype_H1_1(0, 2, 1, -1)
            sage: Y9 = X9.abelian_cover()
            sage: Y9.dimension() == X9.dimension()
            True
            sage: Y9.stratum()  # optional - surface_dynamics
            H_2(1^2)

            sage: F = StrebelGraphLinearFamily("(0,1:1,~0,~1:1)", [[2, 1]])
            sage: Fab = F.abelian_cover()
            sage: Fab
            StrebelGraphLinearFamily("(0,~2:1,~0,2:1)(1:1,3,~1:1,~3)", [(2, 1, 1, 2)])
            sage: print(F.stratum(), Fab.stratum())  # optional - surface_dynamics
            H_1(2, -2) (H_1(2, -2), H_1(2, -2))
        """
        t = self._constellation_class.abelian_cover(self)
        assert t._n == 2 * self._n
        assert t.num_edges() == 2 * self.num_edges() - self.num_folded_edges() == self._n
        nr = self._subspace.nrows()
        subspace = self._subspace.new_matrix(nr, self._n)
        for i in range(self._subspace.nrows()):
            for e in range(self._n):
                if self._ep[e] < e:
                    subspace[i, e] = self._subspace[i, self._ep[e]]
                else:
                    subspace[i, e] = self._subspace[i, e]
        f = self.__class__.from_permutations(t._vp, t._ep, t._fp, t._data, mutable=True, check=False)
        f._constellation_class_init()
        f._subspace = subspace
        if not mutable:
            f.set_immutable()
        f._check()
        return f


class VeeringTriangulationLinearFamily(LinearFamily, VeeringTriangulation):
    r"""
    Veering triangulation together with a subspace of H^1(S, Sigma; \bR) that
    describes a (piece of a) linear GL(2,R)-invariant immersed sub-orbifold.
    """
    __slots__ = ['_constellation_class', '_subspace']

    def veering_triangulation(self, mutable=False):
        r"""
        Return the underlying veering triangulation.

        EXAMPLES::

            sage: from veerer import VeeringTriangulation
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", "RRB")
            sage: vt.as_linear_family().veering_triangulation() == vt
            True
        """
        return VeeringTriangulation.copy(self, mutable, cls=VeeringTriangulation)

    def _horizontal_subspace(self):
        mat = copy(self._subspace)
        ne = self.num_edges()
        ep = self._ep
        for j in range(ne):
            if ep[j] < j:
                raise ValueError('not in standard form')
            if self._colouring[j] == BLUE:
                for i in range(mat.nrows()):
                    mat[i, j] *= -1
        return mat

    def generators_matrix(self, slope=VERTICAL, mutable=None):
        if slope == VERTICAL:
            if not self._mutable and not mutable:
                return self._subspace
            else:
                subspace = self._subspace.__copy__()
                if not mutable:
                    subspace.set_immutable()
                return subspace
        elif slope == HORIZONTAL:
            subspace = self._horizontal_subspace()
            if not mutable:
                subspace.set_immutable()
            return subspace
        else:
            raise ValueError

    def rotate(self):
        r"""
        Conjugate this family.

        EXAMPLES::

            sage: from veerer import *

            sage: fp = "(0,1,2)(~0,~4,~2)(3,4,5)(~3,~1,~5)"
            sage: cols = "BRRBRR"
            sage: f = VeeringTriangulation(fp, cols).as_linear_family(mutable=True)
            sage: f.rotate()
            sage: f
            VeeringTriangulationLinearFamily("(0,1,2)(3,4,5)(~5,~3,~1)(~4,~2,~0)", "RBBRBB", [(1, 0, -1, 0, 0, 0), (0, 1, 1, 0, 1, 1), (0, 0, 0, 1, 0, -1)])

            sage: fp = "(0,12,~11)(1,13,~12)(2,14,~13)(3,15,~14)(4,17,~16)(5,~10,11)(6,~3,~17)(7,~2,~6)(8,~5,~7)(9,~0,~8)(10,~4,~9)(16,~15,~1)"
            sage: cols = "RRRRRRBBBBBBBBBBBB"
            sage: f = VeeringTriangulation(fp, cols).as_linear_family(mutable=True)
            sage: f.rotate()
            sage: f
            VeeringTriangulationLinearFamily("(0,12,~11)(1,13,~12)(2,14,~13)(3,15,~14)(4,17,~16)(5,~10,11)(6,~3,~17)(7,~2,~6)(8,~5,~7)(9,~0,~8)(10,~4,~9)(16,~15,~1)", "BBBBBBRRRRRRRRRRRR", [(1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0), (0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 2, 2, 1, 1, 1, 0, 0), (0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0), (0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1), (0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0), (0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)])
        """
        if not self._mutable:
            raise ValueError('immutable veering triangulation family; use a mutable copy instead')

        subspace = self._horizontal_subspace()
        subspace.echelonize()
        super().rotate()
        self._subspace = subspace

        # TODO: remove check
        self._check()

    def _set_subspace_constraints(self, insert, x, slope):
        ambient_dim = self._subspace.ncols()
        if slope == VERTICAL:
            subspace = self._subspace
        elif slope == HORIZONTAL:
            subspace = self._horizontal_subspace()
        for row in subspace.right_kernel_matrix():
            insert(sum(row[i] * x[i] for i in range(ambient_dim)) == 0)

    def _check(self, error=ValueError):
        LinearFamily._check(self, error)

        # test that elements satisfy the switch condition
        subspace = self._subspace
        for v in subspace.rows():
            self._set_switch_conditions(self._tt_check, v, VERTICAL)

    def train_track_polytope(self, slope=VERTICAL, low_bound=0, backend=None):
        r"""
        Return the polytope of non-negative elements in the subspace.

        EXAMPLES::

            sage: from veerer import *
            sage: vt, s, t = VeeringTriangulations.L_shaped_surface(1, 3, 1, 1)
            sage: f = VeeringTriangulationLinearFamily(vt, [s, t])
            sage: f.train_track_polytope(VERTICAL)
            Cone of dimension 2 in ambient dimension 7 made of 2 facets (backend=ppl)
            sage: f.train_track_polytope(HORIZONTAL)
            Cone of dimension 2 in ambient dimension 7 made of 2 facets (backend=ppl)

            sage: sorted(f.train_track_polytope(VERTICAL).rays())
            [[0, 1, 3, 3, 1, 1, 0], [1, 0, 0, 1, 1, 1, 1]]
            sage: sorted(f.train_track_polytope(HORIZONTAL).rays())
            [[1, 0, 0, 1, 1, 1, 1], [3, 1, 3, 0, 2, 2, 3]]
        """
        ne = self.num_edges()
        L = LinearExpressions(self.base_ring())
        cs = ConstraintSystem()
        for i in range(ne):
            cs.insert(L.variable(i) >= low_bound)
        self._set_subspace_constraints(cs.insert, [L.variable(i) for i in range(ne)], slope)
        return cs.cone(backend)

    def flip(self, e, col, check=True):
        r"""
        EXAMPLES::

            sage: from veerer import *

            sage: T, s, t = VeeringTriangulations.L_shaped_surface(1, 1, 1, 1)

            sage: L = VeeringTriangulationLinearFamily(T, [s, t], mutable=True)
            sage: T = T.copy(mutable=True)

            sage: T.flip(3, 2)
            sage: L.flip(3, 2)
            sage: T
            VeeringTriangulation("(0,3,2)(1,4,~0)(5,6,~1)", "BRRBBBB")
            sage: L
            VeeringTriangulationLinearFamily("(0,3,2)(1,4,~0)(5,6,~1)", "BRRBBBB", [(1, 0, 0, 1, 1, 1, 1), (0, 1, 1, -1, 1, 1, 0)])

            sage: L.flip(4, 2)
            sage: T.flip(4, 2)
            sage: T
            VeeringTriangulation("(0,3,2)(1,~0,4)(5,6,~1)", "BRRBBBB")
            sage: L
            VeeringTriangulationLinearFamily("(0,3,2)(1,~0,4)(5,6,~1)", "BRRBBBB", [(1, 0, 0, 1, 1, 1, 1), (0, 1, 1, -1, -1, 1, 0)])

            sage: T.flip(5, 2)
            sage: L.flip(5, 2)
            sage: T
            VeeringTriangulation("(0,3,2)(1,~0,4)(5,~1,6)", "BRRBBBB")
            sage: L
            VeeringTriangulationLinearFamily("(0,3,2)(1,~0,4)(5,~1,6)", "BRRBBBB", [(1, 0, 0, 1, 1, 1, 1), (0, 1, 1, -1, -1, -1, 0)])
        """
        super().flip(e, col, Gx=self._subspace, check=check)
        self._subspace.echelonize()

    def flip_back(self, e, col, check=True):
        super().flip_back(e, col, Gx=self._subspace, check=check)
        self._subspace.echelonize()

    def is_cylindrical(self, col=None):
        r"""
        Return whether this linear family consists of a union of cylinders
        whose moduli are allowed to degenerate to infinity.

        EXAMPLES::

            sage: from veerer import RED, VeeringTriangulation, VeeringTriangulationLinearFamily
            sage: faces = "(0,~2,1)(2,6,~3)(3,5,4)"
            sage: cols = "RBRRBRB"
            sage: K = QuadraticField(5, 'sqrt5')
            sage: sqrt5 = K.gen()
            sage: x = (1, 0, 1, 1/2*sqrt5 + 1/2, -1, 1/2*sqrt5 - 1/2, -1/2*sqrt5 + 1/2)
            sage: y = (0, 1, 1, 0, 1/2*sqrt5 - 1/2, 1/2*sqrt5 - 1/2, 1)
            sage: f = VeeringTriangulationLinearFamily(faces, cols, [x, y])
            sage: f.is_cylindrical(RED)
            False
            sage: VeeringTriangulation.is_cylindrical(f, RED)
            True
        """
        if col is None:
            return self.is_cylindrical(BLUE) or self.is_cylindrical(RED)
        if col != RED and col != BLUE:
            raise ValueError("'col' must be one of RED or BLUE")
        if not super().is_cylindrical(col):
            return False
        cylinders = list(self.cylinders(col))

        C = []  # middle edges
        for cyl in cylinders:
            c = [0] * self.num_edges()  # indicatrix of the middle edges
            for e in cyl[0]:
                c[self._norm(e)] = 1
            C.append(c)

        # take intersection of the cylinder twists in the tangent space
        F = FreeModule(self.base_ring(), self.num_edges())
        H = F.submodule(self._subspace).intersection(F.submodule(C))

        mid_edges = set(i for c in C for i, j in enumerate(c) if j)
        for b in H.basis_matrix():
            for i, j in enumerate(b):
                if j:
                    mid_edges.discard(i)
        return not mid_edges

    def delaunay_cone(self, x_low_bound=0, y_low_bound=0, hw_bound=0, backend=None):
        r"""
        Return the geometric polytope.

        EXAMPLES::

            sage: from veerer import *

            sage: T = VeeringTriangulation("(0,1,2)(~0,~1,~2)", "RRB")
            sage: T.delaunay_cone()
            Cone of dimension 4 in ambient dimension 6 made of 6 facets (backend=ppl)
            sage: T.as_linear_family().delaunay_cone(backend='ppl')
            Cone of dimension 4 in ambient dimension 6 made of 6 facets (backend=ppl)
            sage: T.as_linear_family().delaunay_cone(backend='sage')
            Cone of dimension 4 in ambient dimension 6 made of 6 facets (backend=sage)

        An example in genus 2 involving a linear constraint::

            sage: vt, s, t = VeeringTriangulations.L_shaped_surface(1, 1, 1, 1)
            sage: f = VeeringTriangulationLinearFamily(vt, [s, t])
            sage: PG = f.delaunay_cone(backend='ppl')
            sage: PG
            Cone of dimension 4 in ambient dimension 14 made of 6 facets (backend=ppl)
            sage: sorted(PG.rays())
            [[0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1],
             [0, 1, 1, 1, 1, 1, 0, 2, 0, 0, 2, 2, 2, 2],
             [0, 1, 1, 1, 1, 1, 0, 2, 2, 2, 0, 0, 0, 2],
             [0, 2, 2, 2, 2, 2, 0, 1, 1, 1, 0, 0, 0, 1],
             [1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
             [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
             [2, 0, 0, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 1]]
        """
        ne = self._subspace.ncols()
        L = LinearExpressions(self.base_ring())
        x = [L.variable(i) for i in range(ne)]
        y = [L.variable(ne + i) for i in range(ne)]
        cs = ConstraintSystem()
        for i in range(ne):
            cs.insert(x[i] >= x_low_bound)
        for i in range(ne):
            cs.insert(y[i] >= y_low_bound)
        self._set_subspace_constraints(cs.insert, x, VERTICAL)
        self._set_subspace_constraints(cs.insert, y, HORIZONTAL)
        self._set_delaunay_constraints(cs.insert, x, y, hw_bound=hw_bound)
        return cs.cone(backend)

    def random_forward_flip(self, repeat=1):
        r"""
        Apply a random forward flip randomly among the ones that keeps the family core.

        INPUT:

        - ``repeat`` - integer (default 1) - if provided, make ``repeat`` flips instead
          of 1

        EXAMPLES::

            sage: from veerer.linear_family import VeeringTriangulationLinearFamilies
            sage: X = VeeringTriangulationLinearFamilies.prototype_H1_1(0, 4, 1, 0, mutable=True)
            sage: X.is_core()
            True
            sage: X.is_delaunay()
            False
            sage: while not X.is_delaunay():
            ....:     X.random_forward_flip()
        """
        if not self._mutable:
            raise ValueError('immutable veering triangulation family; use a mutable copy instead')

        cols = [RED, BLUE]
        for _ in range(repeat):
            e = choice(self.forward_flippable_edges())
            old_col = self._colouring[e]
            shuffle(cols)
            for c in cols:
                self.flip(e, c)
                # NOTE: for veering triangulation, the following check is made much faster
                # with edge_has_curve. However for families, we have additional linear
                # constraints on the curve that makes it harder to build.
                if self.is_core():
                    break
                else:
                    self.flip_back(e, old_col)

    def strebel_graph(self, slope=VERTICAL, mutable=False):
        r"""
        EXAMPLES::

            sage: from veerer import *

            sage: triangles = "(0,1,2)(~1,3,4)(~3,5,6)(~6,7,8)"
            sage: boundary = "(~0:1,~2:1,~4:1,~8:1,~7:1,~5:1)"
            sage: colours = "BBRRRRBRB"
            sage: vt = VeeringTriangulation(triangles, boundary, colours)
            sage: v0,v1,v2,v3,v4 = vt.as_linear_family()._subspace.rows()
            sage: VeeringTriangulationLinearFamily(vt, [v0 + v1 + v2 + v3 + v4]).strebel_graph()
            StrebelGraphLinearFamily("(0,1,~1:1,~0,2,~3,4,~4:1,3,~2)", [(1, 0, 1, 0, 1)])
            sage: VeeringTriangulationLinearFamily(vt, [v0 + v1 + v2, v3 + v4]).strebel_graph()
            StrebelGraphLinearFamily("(0,1,~1:1,~0,2,~3,4,~4:1,3,~2)", [(1, 0, 1, 0, 1), (0, 0, 0, 1, 1)])
            sage: VeeringTriangulationLinearFamily(vt, [v0, v1 + v2, v3 + v4]).strebel_graph()
            StrebelGraphLinearFamily("(0,1,~1:1,~0,2,~3,4,~4:1,3,~2)", [(1, 0, 1, 0, 1), (0, 1, 0, 0, 0), (0, 0, 0, 1, 1)])

            sage: vt = VeeringTriangulation("(1,4,~2)(2,~6,~3)(3,~5,~4)", boundary="(0:1)(5:1)(6:1)(~1:1,~0:1)", colouring="BBRRBBB")
            sage: F = VeeringTriangulationLinearFamily(vt, [(1, 2, 0, -1, 2, 1, 1), (0, 0, 1, 1, -1, 0, 0)])
            sage: F
            VeeringTriangulationLinearFamily("(1,4,~2)(2,~6,~3)(3,~5,~4)", boundary="(0:1)(5:1)(6:1)(~1:1,~0:1)", colouring="BBRRBBB", [(1, 2, 0, -1, 2, 1, 1), (0, 0, 1, 1, -1, 0, 0)])
            sage: F.strebel_graph()
            StrebelGraphLinearFamily("(0)(1,~2)(2,~3,~1,~0)(3)", [(1, 0, 1, 1), (0, 1, -1, 0)])

            sage: vt = VeeringTriangulation("(0,5,~4)(2,6,~5)(3,~0,7)(4,~3,~1)", boundary="(1:1)(~7:1)(~6:1)(~2:1)", colouring="RRRBBBBB")
            sage: f1 = vt.add_residue_constraints([[1, 1, 1, 0]])
            sage: f1.strebel_graph().residue_constraints().echelon_form()
            [1 1 1 0]
            [0 0 0 1]
        """
        indices = [e for e in range(self._n // 2) if self.is_half_edge_strebel(e, slope) and self.is_half_edge_strebel(self._ep[e], slope)]
        G = VeeringTriangulation.strebel_graph(self, slope, mutable=False)
        subspace = self.generators_matrix(slope).matrix_from_columns(indices)
        return StrebelGraphLinearFamily(G, subspace, mutable=mutable)



class StrebelGraphLinearFamily(LinearFamily, StrebelGraph):
    r"""
    EXAMPLES::

        sage: from veerer import StrebelGraphLinearFamily
        sage: G = StrebelGraphLinearFamily("(0,1,2)(~0,~1:1,~2:2)", [(1, 1, 0), (1, 0, 1)])
        sage: G
        StrebelGraphLinearFamily("(0,1,2)(~2:2,~0,~1:1)", [(1, 0, 1), (0, 1, -1)])
        sage: G.dimension()
        2
    """
    __slots__ = ['_constellation_class', '_subspace']

    def is_core(self):
        r"""
        Return whether this linear family of Strebel graphs is core.

        A linear family of Strebel graphs is core if it has a positive solution
        (ie a non-degenerate edge-length vector).

        EXAMPLES::

            sage: from veerer import StrebelGraphLinearFamily

            sage: G = StrebelGraphLinearFamily("(0,1,2)(~0,~1:1,~2:2)", [(1, 1, 0), (-1, 0, 2)])
            sage: G.is_core()
            True

            sage: G = StrebelGraphLinearFamily("(0,1,2)(~0,~1:1,~2:2)", [(1, 1, -1), (-1, 0, 1)])
            sage: G.is_core()
            False
        """
        return self.cone().affine_dimension() == self.dimension()

    def _set_subspace_constraints(self, insert, x):
        ambient_dim = self._subspace.ncols()
        subspace = self._subspace
        for row in subspace.right_kernel_matrix():
            insert(sum(row[i] * x[i] for i in range(ambient_dim)) == 0)

    def cone(self, backend=None):
        r"""
        Return the cone of of x-coordinates for this linear family.

        EXAMPLES::

            sage: from veerer import StrebelGraph
            sage: F = StrebelGraph("(0,2,~3,~1)(1)(3,~0)(~2)").add_residue_constraints([[0, 1, -1, 0], [0, 1, 0, -1]])
            sage: F.cone(backend='ppl')
            Cone of dimension 2 in ambient dimension 4 made of 2 facets (backend=ppl)
            sage: F.cone(backend='sage')
            Cone of dimension 2 in ambient dimension 4 made of 2 facets (backend=sage)
            sage: F.cone(backend='normaliz-QQ')  # optional - pynormaliz
            Cone of dimension 2 in ambient dimension 4 made of 2 facets (backend=normaliz-QQ)
        """
        from .polyhedron import LinearExpressions, ConstraintSystem
        L = LinearExpressions(self.base_ring())
        ne = self.num_edges()
        x = [L.variable(i) for i in range(ne)]
        cs = ConstraintSystem(ne)
        self._set_strebel_constraints(cs.insert, x)
        self._set_subspace_constraints(cs.insert, x)
        return cs.cone(backend=backend)

    def add_residue_constraints(self, residue_constraints):
        r"""
        Return the Strebel graph linear family obtained by adding the given
        linear constraints on the residues.

        Note that the resulting family might not intersect the relative
        interior of the Strebel cone. To check whether this is the case, use
        the method ``is_core``.

        EXAMPLES::

            sage: from veerer import StrebelGraph
            sage: G = StrebelGraph("(0,2,~3,~1)(1)(3,~0)(~2)")
            sage: f1 = G.add_residue_constraints([[0, 1, -1, 0]]).add_residue_constraints([[0, 1, 0, -1]])
            sage: f2 = G.add_residue_constraints([[0, 1, -1, 0], [0, 1, 0, -1]])
            sage: f1 == f2
            True
        """
        if not isinstance(residue_constraints, Matrix):
            residue_constraints = matrix(residue_constraints)

        base_ring = cm.common_parent(self.base_ring(), residue_constraints.base_ring())
        nr = self._subspace.nrows()
        nc = self._subspace.ncols()
        constraint_matrix = matrix(base_ring, (nc - nr) + residue_constraints.nrows(), self.num_edges())
        constraint_matrix[:nc - nr, :] = self._subspace.right_kernel_matrix()
        constraint_matrix[nc - nr:, :] = residue_constraints * self.residue_matrix()
        gens = constraint_matrix.right_kernel_matrix()
        from .linear_family import StrebelGraphLinearFamily
        return StrebelGraphLinearFamily(self, gens)

    def veering_triangulations(self, colouring, slope=VERTICAL, mutable=False):
        r"""
        EXAMPLES::

            sage: from veerer import StrebelGraphLinearFamily
            sage: G = StrebelGraphLinearFamily("(0,1,2)(~0,~1:1,~2:2)", [(1, 1, 0), (1, 0, 1)])
            sage: for colouring in G.colourings():
            ....:     print(colouring, sum(1 for _ in G.veering_triangulations(colouring)), sum(1 for _ in G.delaunay_triangulations(colouring)))
            ....:     assert all(vt.strebel_graph() == G for vt in G.veering_triangulations(colouring))
            ....:     assert all(vt.strebel_graph() == G for vt in G.delaunay_triangulations(colouring))
            array('i', [1, 1, 1, 1, 1, 1]) 1 1
            array('i', [1, 1, 2, 2, 1, 1]) 6 2
            array('i', [1, 2, 1, 1, 2, 1]) 3 1
            array('i', [1, 2, 2, 2, 2, 1]) 6 0
            array('i', [2, 1, 1, 1, 1, 2]) 3 0
            array('i', [2, 1, 2, 2, 1, 2]) 3 2
            array('i', [2, 2, 1, 1, 2, 2]) 3 1
            array('i', [2, 2, 2, 2, 2, 2]) 1 1
        """
        for vt in StrebelGraph.veering_triangulations(self, colouring, slope, mutable):
            switch = vt.generators_matrix(mutable=True)
            switch.echelonize()
            assert switch[:self.num_edges(), :self.num_edges()].is_one()
            subspace = []
            for row in self._subspace.rows():
                subspace.append(sum(x * switch.row(i) for i, x in enumerate(row)))
            yield VeeringTriangulationLinearFamily(vt, subspace, mutable=mutable)


class VeeringTriangulationLinearFamilies:
    r"""
    A collection of linear families.
    """
    @staticmethod
    def H2_prototype_parameters(D, spin=None):
        r"""
        Return the list of prototypes in a given discriminant ``D``.

        If ``spin`` is provided, then return only the prototypes with the given
        spin parameter.

        EXAMPLES::

            sage: from veerer.linear_family import VeeringTriangulationLinearFamilies
            sage: list(VeeringTriangulationLinearFamilies.H2_prototype_parameters(5))
            [(0, 1, 1, -1)]
            sage: list(VeeringTriangulationLinearFamilies.H2_prototype_parameters(8))
            [(0, 2, 1, 0), (0, 1, 1, -2)]
            sage: list(VeeringTriangulationLinearFamilies.H2_prototype_parameters(9))
            [(0, 2, 1, -1)]
            sage: list(VeeringTriangulationLinearFamilies.H2_prototype_parameters(12))
            [(0, 3, 1, 0), (0, 1, 2, -2), (0, 2, 1, -2)]
            sage: list(VeeringTriangulationLinearFamilies.H2_prototype_parameters(13))
            [(0, 3, 1, 1), (0, 3, 1, -1), (0, 1, 1, -3)]
            sage: list(VeeringTriangulationLinearFamilies.H2_prototype_parameters(16))
            [(0, 4, 1, 0),  (0, 3, 1, -2)]

            sage: list(VeeringTriangulationLinearFamilies.H2_prototype_parameters(17, spin=0))
            [(1, 2, 2, -1), (0, 4, 1, 1), (0, 2, 1, -3)]
            sage: list(VeeringTriangulationLinearFamilies.H2_prototype_parameters(17, spin=1))
            [(0, 2, 2, -1), (0, 4, 1, -1), (0, 1, 2, -3)]
        """
        # NOTE: for the spin computation, decompose D = E f^2 and the spin is
        #  (e - f) / 2 + (c + 1)(a + b + a*b) mod 2

        from sage.rings.integer_ring import ZZ

        if not isinstance(D, numbers.Integral):
            raise ValueError('D must be an integer')
        D = ZZ(D)
        if D <= 4 or not D % 4 in [0, 1]:
            raise ValueError('D must be an integer > 4 congruent to either 0 or 1 mod 4')

        if spin is not None:
            if D % 8 != 1:
                raise ValueError('spin can only be specified if D is congruent to 1 mod 8')
            if not isinstance(spin, numbers.Integral):
                raise ValueError('spin must be an integer')
            spin = ZZ(spin)
            if spin not in [0, 1]:
                raise ValueError('spin must either be 0 or 1')

        E = D.squarefree_part()
        f = (D // E).sqrtrem()[0]

        e = D % 4
        while e**2 < D:
            assert (D - e**2) % 4 == 0
            bc = (D - e**2) // 4
            for b in bc.divisors():
                c = bc // b
                # need c + e < b
                if e == 0:
                    signs = (1,)
                else:
                    signs = (1, -1)
                for s in signs:
                    if c + s*e < b:
                        for a in range(gcd(b, c)):
                            if gcd([a, b, c, e]) == 1:
                                if spin is None or ((s*e - f) // 2 + (c + 1) * (a + b + a*b)) % 2 == spin:
                                    yield (a, b, c, s*e)
            e += 2

    @staticmethod
    def prototype_H2(a, b, c, e, mutable=False):
        r"""
        Return the Mcmullen prototype with parameters ``(a, b, c, e)`` or rather
        its quotient in `Q(1, -1^5)`.

        EXAMPLES::

            sage: from veerer.linear_family import VeeringTriangulationLinearFamilies
            sage: from veerer.automaton import DelaunayAutomaton

            sage: X9 = VeeringTriangulationLinearFamilies.prototype_H2(0, 2, 1, -1)
            sage: X9.base_ring()
            Rational Field
            sage: X9.is_delaunay()
            True
            sage: A = DelaunayAutomaton()
            sage: A.add_seed(X9)
            1
            sage: A.run()
            0
            sage: A
            Delaunay automaton with 6 vertices

            sage: X17 = VeeringTriangulationLinearFamilies.prototype_H2(0, 2, 2, -1)
            sage: X17.base_ring()
            Number Field in sqrt17 with defining polynomial x^2 - 17 with sqrt17 = 4.123105625617660?
            sage: X17.is_delaunay()
            True
            sage: A = DelaunayAutomaton()
            sage: A.add_seed(X17)
            1
            sage: A.run()  # long time
            0
            sage: A  # long time
            Delaunay automaton with 210 vertices

        We check below part of McMullen theorem about connectedness::

            sage: a0, b0, c0, e0 = next(VeeringTriangulationLinearFamilies.H2_prototype_parameters(17, spin=0))
            sage: X17_0 = VeeringTriangulationLinearFamilies.prototype_H2(a0, b0, c0, e0)
            sage: A0 = DelaunayAutomaton(backend='sage')
            sage: A0.add_seed(X17_0)
            1
            sage: A0.run()  # long time
            0
            sage: for a, b, c, e in VeeringTriangulationLinearFamilies.H2_prototype_parameters(17, spin=0):  # long time
            ....:     X = VeeringTriangulationLinearFamilies.prototype_H2(a, b, c, e, mutable=True)
            ....:     X.set_canonical_labels()
            ....:     X.set_immutable()
            ....:     assert X in A0

            sage: a1, b1, c1, e1 = next(VeeringTriangulationLinearFamilies.H2_prototype_parameters(17, spin=1))
            sage: X17_1 = VeeringTriangulationLinearFamilies.prototype_H2(a1, b1, c1, e1)
            sage: A1 = DelaunayAutomaton(backend='sage')
            sage: A1.add_seed(X17_1)
            1
            sage: A1.run()  # long time
            0
            sage: for a, b, c, e in VeeringTriangulationLinearFamilies.H2_prototype_parameters(17, spin=1):  # long time
            ....:     X = VeeringTriangulationLinearFamilies.prototype_H2(a, b, c, e, mutable=True)
            ....:     X.set_canonical_labels()
            ....:     X.set_immutable()
            ....:     assert X in A1
        """
        #         (a,c)
        #           x-------x---------x  (a+b,c)
        #          /                 /
        #         /                 /
        # (0,0)  x-------x---------x  (b,0)
        #        |       |
        #        |       |
        #        |       |
        #        x-------x
        #     (0,-lbda)    (lbda,-lbda)
        from sage.rings.integer_ring import ZZ
        from sage.rings.rational_field import QQ
        from sage.rings.number_field.number_field import NumberField
        from sage.rings.qqbar import AA
        if not all(isinstance(x, numbers.Integral) for x in (a, b, c, e)):
            raise ValueError('a, b, c, e must be integers')
        a = ZZ(a)
        b = ZZ(b)
        c = ZZ(c)
        e = ZZ(e)
        if not (0 < b and 0 < c and 0 <= a < gcd(b, c) and c + e < b and gcd([a, b, c, e]) == 1):
            raise ValueError('a, b, c, e must satisfy: 0 < b, 0 < c, 0 <= a < gcd(b, c), c + e < b and gcd(a, b, c, e) = 1')
        D = e**2 + 4*b*c
        if D.is_square():
            K = QQ
            sqrtD = D.sqrtrem()[0]
        else:
            E = D.squarefree_part()
            f = (D // E).sqrtrem()[0]
            x = QQ['x'].gen()
            K = NumberField(x**2 - E, 'sqrt%d' % E, embedding=AA(E).sqrt())
            sqrtD = f * K.gen()

        assert sqrtD**2 == D

        lbda = (e + sqrtD) / 2

        fp = "(~0,5,6)(0,2,4)(~2,3,1)"
        cols = "BBRRRRR"
        vt = VeeringTriangulation(fp, cols, mutable=mutable)

        sx = (lbda, b-lbda, a, b+a-lbda, lbda+a, 0, lbda)
        sy = (0, 0, c, c, c, lbda, lbda)

        return VeeringTriangulationLinearFamily(vt, [sx, sy], mutable=mutable)

    @staticmethod
    def prototype_H1_1(a, b, c, e, mutable=False):
        r"""
        EXAMPLES::

            sage: from veerer.linear_family import VeeringTriangulationLinearFamilies
            sage: from veerer.automaton import DelaunayAutomaton

            sage: X9 = VeeringTriangulationLinearFamilies.prototype_H1_1(0, 2, 1, -1)
            sage: X9.base_ring()
            Rational Field
            sage: X9.delaunay_automaton()  # long time
            Delaunay automaton with 1244 vertices
        """
        #         (a+r,c)         (a+b,c)
        #           x-------x------o--x  (a+b+r,c)
        #          /                 /
        #         /                 /
        # (0,0)  o-------o--x------o  (b+r,0)
        #        \        \   (lbda+r,0)
        #         \        \
        #          \        \
        #           x--------x
        #     (r,-lbda)    (lbda+r,-lbda)
        from sage.rings.integer_ring import ZZ
        from sage.rings.rational_field import QQ
        from sage.rings.number_field.number_field import NumberField
        from sage.rings.qqbar import AA
        if not all(isinstance(x, numbers.Integral) for x in (a, b, c, e)):
            raise ValueError('a, b, c, e must be integers')
        a = ZZ(a)
        b = ZZ(b)
        c = ZZ(c)
        e = ZZ(e)
        if not (0 < b and 0 < c and 0 <= a < gcd(b, c) and c + e < b and gcd([a, b, c, e]) == 1):
            raise ValueError('a, b, c, e must satisfy: 0 < b, 0 < c, 0 <= a < gcd(b, c), c + e < b and gcd(a, b, c, e) = 1')
        D = e**2 + 4*b*c
        if D.is_square():
            K = QQ
            sqrtD = D.sqrtrem()[0]
        else:
            E = D.squarefree_part()
            f = (D // E).sqrtrem()[0]
            x = QQ['x'].gen()
            K = NumberField(x**2 - E, 'sqrt%d' % E, embedding=AA(E).sqrt())
            sqrtD = f * K.gen()

        assert sqrtD**2 == D

        lbda = (e + sqrtD) / 2

        fp = "(0,3,8)(~0,5,6)(~3,4,2)(~4,1,7)"
        cols = "BBBRRRRRR"
        vt = VeeringTriangulation(fp, cols, mutable=mutable)

        sx = (lbda, 0, b-lbda, a, a+b-lbda, 0, lbda, a+b-lbda, lbda+a)
        sy = (0, 0, 0, c, c, lbda, lbda, c, c)
        sr = (0, 1, -1, 1, 0, -1, -1, -1, 1)

        return VeeringTriangulationLinearFamily(vt, [sx, sy, sr], mutable=mutable)

    @staticmethod
    def L_shaped_surface(a1, a2, b1, b2, t1=0, t2=0):
        vt, s, t = VeeringTriangulations.L_shaped_surface(a1, a2, b1, b2, t1, t2)
        return VeeringTriangulationLinearFamily(vt, matrix([s, t]))

    @staticmethod
    def triangle_3_4_13_unfolding_orbit_closure():
        r"""
        EXAMPLES::

            sage: from veerer.linear_family import VeeringTriangulationLinearFamilies
            sage: f = VeeringTriangulationLinearFamilies.triangle_3_4_13_unfolding_orbit_closure()
            sage: f
            VeeringTriangulationLinearFamily("(0,9,~8)(1,8,2)(3,11,~10)(4,~14,15)(5,~15,12)(6,~16,13)(7,~0,22)(10,14,~9)(16,~12,~4)(17,20,~18)(18,~5,~23)(19,~22,~21)(21,~13,23)(~20,~6,~17)(~19,~7,~1)(~11,~2,~3)", "BBRBRBRRRRRRRRBRBBRRRBRR", [(1, phi, 0, 0, 0, 1, 0, 0, -phi, -phi - 1, 0, 0, -phi, -phi, phi + 1, -phi - 1, phi, 0, 0, -phi, 0, phi - 1, -1, -1), (0, 0, 1, 0, 0, 0, phi - 1, 0, 1, 1, 1, 1, 0, phi - 1, 0, 0, 0, 0, phi - 1, 0, phi - 1, 0, 0, phi - 1), (0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, phi - 1, 0, 0, -phi + 1, 0, 0, 0), (0, 0, 0, 0, 1, 0, 0, phi - 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, phi - 1, 0, 0, phi - 1, 0)])

            sage: f.stratum()  # optional - surface_dynamics
            Q_4(11, 1)
        """
        from sage.rings.rational_field import QQ
        from sage.rings.number_field.number_field import NumberField
        from sage.rings.qqbar import AA

        x = QQ['x'].gen()

        fp = "(0,9,~8)(1,8,2)(10,14,~9)(3,11,~10)(~2,~3,~11)(~14,15,4)(12,5,~15)(~4,16,~12)(13,6,~16)(23,21,~13)(18,~5,~23)(17,20,~18)(~6,~17,~20)(~0,22,7)(~21,19,~22)(~7,~1,~19)"
        cols = "BBRBRBRRRRRRRRBRBBRRRBRR"
        vt = VeeringTriangulation(fp, cols)

        # equations (beyond switches)
        # B = phi A
        # S = phi T
        # C = phi D
        # U = phi V
        # where A = 0, B = 1, C = 2, D = 6, S = 3, T = 17, U = 4, V = 7
        K = NumberField(x**2 - x - 1, 'phi', embedding=(AA(5).sqrt() + 1)/2)
        phi = K.gen()
        L = LinearExpressions(K)
        cs = ConstraintSystem()
        vt._set_switch_conditions(cs.insert, [L.variable(e) for e in range(24)])
        A = L.variable(0)
        B = L.variable(1)
        C = L.variable(2)
        C = L.variable(2)
        D = L.variable(6)
        S = L.variable(3)
        T = L.variable(17)
        U = L.variable(4)
        V = L.variable(7)
        cs.insert(B == phi * A)
        cs.insert(S == phi * T)
        cs.insert(C == phi * D)
        cs.insert(U == phi * V)

        return VeeringTriangulationLinearFamily(vt, cs.linear_generators_matrix())

